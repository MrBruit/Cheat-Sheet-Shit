import type { QuestionAnswers } from "../types/type";

export const reactQuiz: QuestionAnswers[] = [
  { id: 1, definition: "Hook permettant de gérer un état local.", correct: "useState", wrong: ["useEffect", "useMemo", "useRef"] },
  { id: 2, definition: "Hook exécuté après le rendu du composant.", correct: "useEffect", wrong: ["useState", "useCallback", "useLayout"] },
  { id: 3, definition: "Hook permettant de mémoriser une valeur calculée.", correct: "useMemo", wrong: ["useState", "useEffect", "useCache"] },
  { id: 4, definition: "Hook permettant de mémoriser une fonction.", correct: "useCallback", wrong: ["useMemo", "useFunction", "useEvent"] },
  { id: 5, definition: "Hook permettant d'accéder à un élément du DOM.", correct: "useRef", wrong: ["useDom", "useElement", "useNode"] },
  { id: 6, definition: "Méthode permettant de créer un contexte global.", correct: "createContext", wrong: ["makeContext", "useContextProvider", "globalContext"] },
  { id: 7, definition: "Hook permettant de consommer un contexte.", correct: "useContext", wrong: ["useProvider", "useInject", "useGlobal"] },
  { id: 8, definition: "Composant utilisé pour définir les routes dans React Router.", correct: "<Routes>", wrong: ["<Switch>", "<Navigator>", "<Paths>"] },
  { id: 9, definition: "Prop permettant de passer des éléments enfants à un composant.", correct: "children", wrong: ["content", "slots", "inner"] },
  { id: 10, definition: "Hook permettant de forcer un rendu basé sur une valeur dérivée.", correct: "useMemo", wrong: ["useEffect", "useState", "useRef"] },
  { id: 11, definition: "Hook permettant d'exécuter du code avant le rendu visuel.", correct: "useLayoutEffect", wrong: ["useEffect", "useBeforeRender", "useSync"] },
  { id: 12, definition: "Hook permettant de gérer un reducer.", correct: "useReducer", wrong: ["useState", "useDispatch", "useAction"] },
  { id: 13, definition: "Hook permettant de gérer un état global léger.", correct: "useContext", wrong: ["useGlobal", "useStore", "useShared"] },
  { id: 14, definition: "Fonction permettant de créer un composant.", correct: "function Component()", wrong: ["new Component()", "createComponent()", "component()"] },
  { id: 15, definition: "Méthode permettant de rendre un composant dans le DOM.", correct: "createRoot()", wrong: ["renderDOM()", "mount()", "inject()"] },
  { id: 16, definition: "Hook permettant de gérer un intervalle proprement.", correct: "useEffect + clearInterval", wrong: ["useInterval", "useTimer", "useLoop"] },
  { id: 17, definition: "Hook permettant de stocker une valeur persistante sans re-render.", correct: "useRef", wrong: ["useState", "useMemo", "usePersist"] },
  { id: 18, definition: "Hook permettant de déclencher un effet uniquement au montage.", correct: "useEffect(() => {}, [])", wrong: ["useMount()", "useInit()", "useStart()"] },
  { id: 19, definition: "Hook permettant de déclencher un effet à chaque rendu.", correct: "useEffect sans dépendances", wrong: ["useLayoutEffect", "useMemo", "useCallback"] },
  { id: 20, definition: "Hook permettant de gérer un formulaire complexe.", correct: "useReducer", wrong: ["useState", "useForm", "useInputs"] },
  { id: 21, definition: "Hook permettant de mémoriser un objet pour éviter les re-renders.", correct: "useMemo", wrong: ["useRef", "useState", "useCache"] },
  { id: 22, definition: "Hook permettant de créer un callback stable.", correct: "useCallback", wrong: ["useMemo", "useStable", "useFunction"] },
  { id: 23, definition: "Hook permettant de synchroniser un effet avec le DOM.", correct: "useLayoutEffect", wrong: ["useEffect", "useSync", "useDOM"] },
  { id: 24, definition: "Hook permettant de gérer un compteur simple.", correct: "useState", wrong: ["useCounter", "useNumber", "useIncrement"] },
  { id: 25, definition: "Hook permettant de gérer un toggle.", correct: "useState", wrong: ["useToggle", "useSwitch", "useBoolean"] },
  { id: 26, definition: "Hook permettant de gérer un tableau d’éléments.", correct: "useState", wrong: ["useArray", "useList", "useCollection"] },
  { id: 27, definition: "Hook permettant d’éviter un re-render inutile.", correct: "useMemo", wrong: ["useEffect", "useRef", "useOptimize"] },
  { id: 28, definition: "Hook permettant de mémoriser une valeur primitive.", correct: "useMemo", wrong: ["useState", "useRef", "usePrimitive"] },
  { id: 29, definition: "Hook permettant de gérer un timer.", correct: "useEffect + setTimeout", wrong: ["useTimer", "useClock", "useDelay"] },
  { id: 30, definition: "Hook permettant de gérer un événement global (scroll, resize).", correct: "useEffect", wrong: ["useEvent", "useGlobal", "useWindow"] },
  { id: 31, definition: "Hook permettant de créer un état dérivé.", correct: "useMemo", wrong: ["useState", "useEffect", "useDerived"] },
  { id: 32, definition: "Hook permettant de stocker une valeur mutable.", correct: "useRef", wrong: ["useState", "useMemo", "useVar"] },
  { id: 33, definition: "Hook permettant de gérer un thème global.", correct: "useContext", wrong: ["useTheme", "useGlobal", "useStyle"] },
  { id: 34, definition: "Hook permettant de gérer un store Redux.", correct: "useSelector", wrong: ["useStore", "useRedux", "useState"] },
  { id: 35, definition: "Hook permettant de dispatcher une action Redux.", correct: "useDispatch", wrong: ["useAction", "useSend", "useTrigger"] },
  { id: 36, definition: "Hook permettant de gérer un effet dépendant d’une valeur.", correct: "useEffect([...])", wrong: ["useMemo([...])", "useCallback([...])", "useRef([...])"] },
  { id: 37, definition: "Hook permettant de créer un ref callback.", correct: "useCallback + ref", wrong: ["useRefCallback", "useRefMemo", "useRefEvent"] },
  { id: 38, definition: "Hook permettant de gérer un composant non contrôlé.", correct: "useRef", wrong: ["useState", "useEffect", "useMemo"] },
  { id: 39, definition: "Hook permettant de gérer un composant contrôlé.", correct: "useState", wrong: ["useRef", "useMemo", "useControl"] },
  { id: 40, definition: "Hook permettant de mémoriser un tableau filtré.", correct: "useMemo", wrong: ["useEffect", "useState", "useFilter"] }
];
